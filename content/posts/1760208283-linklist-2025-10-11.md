+++ 
date = 2025-10-11T19:44:43+01:00
title = "Link List :: 2025-08-25"
description = ""
slug = ""
tags = ["links"]
categories = ["linklist"]
externalLink = ""
series = []
+++

## https://dobretrejdy.com/

## https://www.reddit.com/r/london/comments/17k6ijn/what_is_the_most_underrated_sight_or_attraction/

## https://old.reddit.com/r/LocalLLaMA/comments/1n7bqgm/langextract_by_google_many_people_dont_know_about/

## https://towardsdatascience.com/extracting-structured-data-with-langextract-a-deep-dive-into-llm-orchestrated-workflows/

```
# Introduction
- Observations of pitfalls in raw LLM workflows for structured extraction tasks
- Development of special handling and validation checks to address issues
- Need for an orchestrator to fine-tune prompts, chunk data, and align output with schema

# Why LangExtract?
- Effective management of prompts and outputs between user and LLM
- Fine-tuning of prompt before passing to LLM
- Chunking and parallelization capabilities

# Data Structures and Workflow in LangExtract
- List of custom class objects for examples
- Properties: 'text', 'extraction_class', 'extraction_text', and 'text_or_documents'
- Few-shot prompting instructions sent to chosen LLM through LangExtract
- Core 'extract()' function gathers prompts, fine-tunes prompt internally, and passes to LLM

# A Hands-on Implementation of LangExtract
- Gathering news articles from techxplore.com RSS feeds using Feedparser and Trifaltura
- Creating custom classes for examples and setting up prompts
- Iterating through results in a 'for loop' to write annotated documents to jsonl file
- Gathering every extraction from an annotated document one at a time

# Best Practices for Using LangExtract Effectively
- Few-shot prompting for complex domains with nuanced terminology
- Multi-extraction pass to fill in details missing in output
- Parallelization to speed up extraction process when necessary

# Concluding Remarks
- Use of LangExtract for structured extraction use cases
- Benefits of using an orchestrator like LangExtract for fine-tuning prompts, chunking data, and aligning output with schema
```

## https://codesmash.dev/why-i-ditched-docker-for-podman-and-you-should-too

```
- # Beginnings
  * Vagrant was seen as a promised land for development environments in the past
  * Docker changed how developers thought about application development and deployment with a persistent daemon running in the background
  * This led to repeated questions about security, and vulnerabilities were discovered
  * CVE-2019-5736, "Dirty Pipe" (Linux kernel), and others exposed flaws that could be exploited for host compromise

- # Daemonless
  * Podman throws away the persistent dockerd daemon's model, running containers under user privileges instead of root
  * This reduces security risks and makes the environment more predictable
  * Lighter resource footprint due to no constantly running daemon

- # Systemd integration that doesn‚Äôt suck
  * Podman generates proper systemd unit files for container services
  * Eliminates the need for third-party process managers

- # Kubernetes alignment that's not just marketing
  * Native pod support aligns with Kubernetes best practices
  * Enables prototype multi-container applications locally, then generates Kubernetes YAML from pods

- # The Unix philosophy done right
  * Podman focuses on running containers well and delegates specialized tasks to purpose-built tools like Buildah and Skopeo

- # The Migration That Wasn‚Äôt Really a Migration
  * Switching to Podman was almost seamless due to similar CLI behavior and compatibility with existing Dockerfiles
  * A few improvements in disguise (e.g., improved security, better volume permissions)

- # What You'll Need for FastAPI Migration Guide
  * Existing FastAPI project with Dockerfile and requirements.txt
  * Podman installed on the system

- # Step 1: Your Dockerfile Probably Just Works
  * Podman uses the same OCI container format as Docker, preserving existing Dockerfiles

- # Step 2: Build Your Image
  * Use `podman build` instead of `docker build`
  * Alias can be created for easier transition

- # Step 3: Run Your Container
  * For development and testing, use `podman run --rm -p 8000:8000 --name my-fastapi-container`
  * For background services, use `podman run -d -p 8000:8000 --name my-fastapi-container`

- # Step 4: Production Deployment with Systemd
  * Generate a systemd service file using `podman generate systemd`
  * Enable and start the service

- # Step 5: Multi-Service Applications with Pods
  * Create a pod that shares networking using `podman pod create --name my-fastapi-pod -p 8000:8000 -p 5432:5432`
  * Run FastAPI app and PostgreSQL in the same pod

- # Step 6: Docker Compose Compatibility
  * Options include using `podman-compose` or converting to Kubernetes YAML for a more cloud-native approach

- # Common Gotchas and Solutions
  * Volume permissions can be solved by setting correct ownership
  * Legacy tooling can be fixed by enabling the Podman socket and exporting DOCKER_HOST
  * Performance tuning may require rootless networking stack tuning or running containers in rootful mode
```

## https://github.com/TheAuditorTool/Auditor

```
- Offline-First, AI-Centric SAST & Code Intelligence Platform
    - Comprehensive code analysis platform for security vulnerabilities and code intelligence
    - Finds Security Vulnerabilities: Detects OWASP Top 10, injection attacks, authentication issues, and framework-specific vulnerabilities
    - Tracks Data Flow: Follows untrusted data from sources to sinks to identify injection points
    - Analyzes Architecture: Builds dependency graphs, detects cycles, and measures code complexity
    - Detects Refactoring Issues: Identifies incomplete migrations, API contract mismatches, and cross-stack inconsistencies
    - Runs Industry-Standard Tools: Orchestrates ESLint, Ruff, MyPy, and other trusted linters
    - Produces AI-Ready Reports: Generates chunked, structured output optimized for LLM consumption

- TheAuditor is designed specifically for AI-assisted development workflows, providing ground truth that both developers and AI assistants can trust

- Universal Integration: Integrates with any AI assistant or IDE using aud full
- No SDK, no integration, no setup required - just runs directly from terminal
- Tool Agnostic - Works with ANY AI assistant or IDE

- AI Becomes Self-Correcting:
    - AI writes code
    - AI runs aud full
    - AI reads the ground truth
    - AI fixes its own mistakes
    - Recursive loop until actually correct

- No Human Intervention Required:
    - You never touch the terminal
    - The AI runs everything
    - You just review and approve

- Every developer using AI assistants has this problem:
    - AI writes insecure code
    - AI introduces bugs
    - AI doesn't see the full picture
    - AI can't verify its work

- TheAuditor solves ALL of this. It's not a "nice to have" - it's the missing piece that makes AI development actually trustworthy

- TheAuditor's philosophy:
    - Orchestrates Verifiable Data
    - Built for AI Consumption
    - Focused and Extensible

- Advanced Features:
    - Rich visual intelligence for dependency graphs using Graphviz
    - Multiple view modes: full graph, cycles-only, hotspots, architectural layers, impact analysis
    - Visual Intelligence Encoding: node colors indicate programming language, size shows importance based on connectivity
    - Actionable Insights: focus on what matters with filtered views
    - AI-Readable Output: generate SVG visualizations that LLMs can analyze

- Insights modules:
    - Run insights analysis on existing audit data
    - ML-powered insights (requires: pip install -e ".[ml]")
    - Graph health metrics and recommendations
    - Generate comprehensive insights report

- TheAuditor is a security scanner that identifies vulnerabilities in your code. It must read and analyze security vulnerabilities, write these findings to disk, and process files rapidly.

- Interaction with antivirus software:
    - Running TheAuditor when system load is low for best performance
    - Expect the analysis to take longer than the raw processing time due to AV overhead
    - If your AV quarantines output files in .pf/, you may need to restore them manually

- Contributing:
    - See CONTRIBUTING.md for: how to add new language support, creating security patterns, adding framework-specific rules, development guidelines
    - We especially need help with: GraphQL analysis, Java/Spring support, Go patterns, Ruby on Rails detection, C#/.NET analysis

- TheAuditor is AGPL-3.0 licensed. For commercial use, SaaS deployment, or integration into proprietary systems, please contact via GitHub for licensing options.
```

## https://github.com/Varietyz/Disciplined-AI-Software-Development

```
# Disciplined AI Software Development Methodology
- A structured approach for working with AI on development projects.
- Addresses common issues like code bloat, architectural drift, context dilution, and behavioral inconsistency.
- Uses four stages with systematic constraints, behavioral consistency enforcement, and validation checkpoints.

# Stages of the Methodology
- Planning: Saves debugging time by thoroughly planning upfront.
- Configure AI Custom Instructions: Sets up AI-PREFERENCES.XML as custom instructions for behavioral constraints.
- Share METHODOLOGY.XML for planning session: Collaborates on project structure and phases.
- Work Phase: Builds phase-by-phase, section by section.

# Constraints and Enforcement
- File size limits (‚â§150 lines): Provides smaller context windows, focused implementation, and easier sharing.
- Architectural checkpoints: Forces consistent behavior through systematic constraints.
- Behavioral constraint enforcement: Persona system prevents AI drift through systematic character validation.

# Empirical Validation
- Performance data replaces subjective assessment for optimization decisions.
- Measurable outcomes reduce debugging time and improve code quality.

# Code Quality
- Architectural consistency across components.
- Measurable performance characteristics.
- Maintainable structure as projects scale.

# LLM Models Q&A Documentation
- Explores detailed Q&A for each AI model: Grok 3, Claude Sonnet 4, DeepSeek-V3, Gemini 2.5 Flash.

# Configuration Process
- Configure AI with AI-PREFERENCES.XML as custom instructions.
- Share CORE-PERSONA-FRAMEWORK.json + selected PERSONA.json.
- Issue command: "Simulate Persona".
- Share METHODOLOGY.XML for planning session.
- Collaborate on project structure and phases.

# Personas
- GUIDE-PERSONA.json - Methodology enforcement specialist.
- TECDOC-PERSONA.json - Technical documentation specialist.
- R&D-PERSONA.json - Research scientist with absolute code quality standards.
- MURMATE-PERSONA.json - Visual systems specialist.

# Core Documents Reference
- AI-PREFERENCES.XML - Behavioral constraints.
- METHODOLOGY.XML - Technical framework.
- README.XML - Implementation guidance.

# Tools and Scripts
- python scripts/project_extract.py: Generates structured snapshots of codebase with syntax highlighting and tree structure visualization.

# Principles and Failures
- Problem: Repeatedly restating preferences to AI systems that produce suboptimal results.
- Breakthrough: Focused questions in proper context reduce errors.
- Constraints work: Trial and error, but effective instruments for software development.
```

## https://github.com/sentient-agi/ROMA

```
- # Introduction to ROMA (recursive hierarchical structures for complex problem-solving)
- # Setup and configuration options for ROMA framework
- # Guide to creating and customizing agents in ROMA
- # Detailed configuration options and environment setup
- # Roadmap for future updates and development of ROMA
- # Overview of ROMA's recursive plan‚Äìexecute loop:
    - Atomizer: Decides whether a request is atomic or requires planning
    - Planner: Breaks down tasks into smaller subtasks if planning is needed
    - Executors: Handle atomic tasks, such as LLMs or APIs
    - Aggregator: Collects and integrates results from subtasks
- # Architecture of ROMA:
    - Top-down: Tasks are decomposed into subtasks recursively
    - Bottom-up: Subtask results are aggregated upwards into solutions for parent tasks
    - Left-to-right: If a subtask depends on the output of a previous one, it waits until that subtask completes before execution
- # Features and capabilities of ROMA:
    - Parallel problem solving where agents work simultaneously on different parts of complex tasks
    - Transparent development with clear structure for easy debugging
    - Proven performance demonstrated through benchmark results
    - Open-source and extensible platform for community-driven development
- # Example agents built using ROMA:
    - Versatile agent powered by ChatGPT Search Preview for handling diverse tasks
    - Comprehensive research system that breaks down complex research questions into manageable subtasks
    - Specialized financial analysis agent with deep blockchain and DeFi expertise
- # Installing and setting up ROMA:
    - Automatic setup with Docker or native installation
    - Accessing pre-defined agents through the frontend on localhost:3000
    - Configuring E2B sandboxes for secure code execution capabilities
- # Evaluation of ROMA's search system across three benchmarks: SEAL-0, FRAMES, and SimpleQA
- # Comprehensive evaluation dataset designed to test the capabilities of Retrieval-Augmented Generation (RAG) systems
- # Features of ROMA:
    - Seamlessly integrate external tools and protocols with configurable intervention points
    - Stage tracing shows exactly what happens at each step for debugging and optimization
    - Works with any provider through unified interface
- # Acknowledgments:
    - Inspired by "Beyond Outlining: Heterogeneous Recursive Planning" by Xiong et al.
    - Pydantic, Agno, and E2B open-source contributions
- # Licensing:
    - Apache 2.0 License (see LICENSE file for details)
```

## https://github.com/tomas-ravalli/product-analytics-framework

```
# Product Analytics Framework
A systematic framework for product analytics that converts raw data into validated insights.

### Core Components
* Theory Layer:
    + Exploration: Gathering and exploring qualitative and quantitative data to understand user behavior.
    + Theory Building: Creating conceptual models and User & Behavior Typologies to explain observed phenomena.
    + Hypothesis Generation: Translating abstract theories into concrete, testable statements.
* Inference Layer:
    + Foundational Analysis: Applying statistical methods to generate Observational and Comparative insights.
    + Advanced Modeling: Using Experimentation (A/B tests), Quasi-experiments, and Machine Learning models to generate Causal and Predictive insights.
* Activation Layer:
    + Actionable Insights: Validated outputs from the Inference Layer, categorized as Observational, Comparative, Causal, or Predictive.
    + Action: Concrete implementation of an insight.
    + Product Strategy: Strategic influence of insights on product strategy, roadmap, and tactics.

### Key Roles
* UX Researcher: Provides qualitative data through user interviews, surveys, and usability studies.
* Product Data Scientist: Supplies quantitative data and executes analyses to generate validated insights.
* Product Engineer: Executes actions by building and shipping features.
* Product Designer: Translates actionable insights into tangible user experiences.
* Product Manager: Consumes actionable insights to shape product strategy.

### Feedback Loops
* Activation Layer ‚Üí Exploration: Driving the iterative evolution of the product itself.
* Inference Layer ‚Üí Theory Building: Ensuring a disciplined re-evaluation of assumptions based on analytical outcomes.

### References
* Rodrigues, J. (2021). Product Analytics: Applied Data Science Techniques for Actionable Consumer Insights. Addison-Wesley.
* Croll, A., & Yoskovitz, B. (2013). Lean Analytics: Use Data to Build a Better Startup Faster. O'Reilly Media.
* Meadows, D. H. (2008). Thinking in Systems: A Primer. Chelsea Green Publishing.
```

Note: I've reformatted the raw markdown content into a more readable format while preserving the original structure and information.

## https://github.com/koladev32/mcp-config-generator

```
* # mcp-config-generator
* * Generates ready-to-use configs for multiple MCP clients:
    + Remote servers (Cursor, Claude Desktop, VS Code, Continue, AnythingLLM, Qodo Gen, Kiro, Opencode, Gemini CLI)
    + npm packages (same list as above)
    + Local scripts (Cursor + Claude Desktop)
* * Open-source tool available under MIT License
* * Made with ‚ù§Ô∏è by Koladev
* # Installation instructions:
    + Clone the repository: `git clone https://github.com/koladev32/mcp-config-generator.git`
    + Install dependencies: `npm install`
    + Run development server: `npm run dev`
    + Build for production: `npm run build`
    + Run tests: `npm test`
* * Add support for a new MCP client by editing `src/config/mcp-clients.ts`
```
s
## https://github.com/C4illin/ConvertX

```
* A self-hosted online file converter supporting over a thousand formats, built with TypeScript, Bun, and Elysia
* Supports:
	+ Converting files to different formats
	+ Processing multiple files at once
	+ Password protection
	+ Multiple accounts
* Supported converters:
	+ Inkscape (vector images)
	+ libjxl (JPEG XL)
	+ resvg (SVG)
	+ Vips (images)
	+ libheif (HEIF)
	+ XeLaTeX (LaTeX)
	+ Calibre (e-books)
	+ LibreOffice (documents)
	+ Dasel (data files)
	+ Pandoc (documents)
	+ msgconvert (Outlook)
	+ dvisvgm (vector images)
	+ ImageMagick (images)
	+ GraphicsMagick (images)
	+ Assimp (3D assets)
	+ FFmpeg (video)
	+ Potrace ( raster to vector)
	+ VTracer ( raster to vector)
* Docker Compose configuration:
	+ `convertx` service:
		- Image: ghcr.io/c4illin/convertx
		- Ports: 3000:3000
		- Environment variables
		- Volumes
* Docker run command:
	+ `-p 3000:3000 -v ./data:/app/data`
* Usage:
	+ Visit http://localhost:3000 to create an account
	+ Set `JWT_SECRET` environment variable for security
* Configuration options:
	+ `JWT_SECRET`: long and secret string used to sign JSON Web Tokens
	+ `ACCOUNT_REGISTRATION`: allow users to register accounts
	+ `HTTP_ALLOWED`: allow HTTP connections (only set to true locally)
	+ `ALLOW_UNAUTHENTICATED`: allow unauthenticated users to use the service (only set to true locally)
	+ `AUTO_DELETE_EVERY_N_HOURS`: checks for files older than n hours and deletes them
	+ `WEBROOT`: address to serve the website on
* Tags:
	+ :latest: updated with every release
	+ :main: updated with every push to the main branch
```

## https://github.com/floRaths/uv-ship?tab=readme-ov-file

```
* A CLI-tool for shipping with uv
* UV-ship is a lightweight companion to uv that removes the risky parts of cutting a release
* Verifies the repo state, bumps your project metadata and optionally refreshes the changelog
* Commits, tags & pushes the result while giving you the chance to review every step
* Please refer to the docs to get started
```

## https://github.com/TheDarkNight21/edge-foundry

```markdown
- üéØ One-Command Deployment - Deploy any GGUF model with a single CLI command
- üìä Real-Time Dashboard - Beautiful React UI with live metrics, performance charts, and model switching
- üîÑ Multi-Model Support - Switch between TinyLlama, Phi-3 Mini, and custom models on-the-fly
- üìà Advanced Telemetry - Track latency, tokens/sec, memory usage, and performance trends
- üõ†Ô∏è Production Ready - FastAPI backend with CORS, health checks, and process management
- üíæ Local-First - Everything runs locally with SQLite storage - no cloud dependencies
```

## https://github.com/Ga0512/video-analysis

```
*   FFmpeg required to extract audio
*   OpenCV and Pillow installed
*   Windows:
    *   Install Gyan.FFmpeg using winget
    *   Install ffmpeg using choco
*   macOS:
    *   Install ffmpeg using brew
*   Ubuntu/Debian:
    *   Install ffmpeg using apt
*   Verify FFmpeg version
```

